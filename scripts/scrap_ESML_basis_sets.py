#!/usr/bin/env python3
"""
Update the list of basis sets from ESML basis set exchange.
"""

import argparse
import requests
import os
from bs4 import BeautifulSoup
from datetime import datetime

JS_PEID = 11535052407933
SCRAP_URL = 'https://bse.pnl.gov/bse/portal/user/anon/js_peid/{}/panel/Main/template/content'
DESTINATION_FILE = 'qcip_tools/basis_set_esml.py'
DEFINITION_BS = 'new basisSet('

FILE_CONTENT = """\"\"\"
Basis sets obtained from ESML basis set exchange on {} (autogenerated, do not edit)
\"\"\"

JS_PEID = {}
AUTHORIZED_TYPES = [
    'NWChem', 'Gaussian94', 'GAMESS-US', 'GAMESS-UK', 'Turbomole', 'TX93', 'Molpro', 'MolproInt', 'Hondo',
    'SuperMolecule', 'Molcas', 'HyperChem', 'Dalton', 'deMon-KS', 'deMon2k', 'AcesII']


class ESMLBasisSet:
    \"\"\"Store data for a given basis set\"\"\"

    def __init__(self, name, path, atoms):
        self.name = name
        self.path = path
        self.atoms = atoms


# the basis sets:
AVAILABLE_BS = {{
{}
}}
"""

__version__ = '0.1'
__author__ = 'Pierre Beaujean'
__maintainer__ = 'Pierre Beaujean'
__email__ = 'pierre.beaujean@unamur.be'
__status__ = 'Development'


parser = argparse.ArgumentParser(__doc__)

parser.add_argument(
    '-i', '--jspeid', action='store', default=JS_PEID, help='js peid')

parser.add_argument(
    '-d', '--destination', action='store', default=DESTINATION_FILE, help='where to write the basis sets')


def main():
    args = parser.parse_args()
    print(__doc__)

    if not os.path.exists(DESTINATION_FILE):
        print('cannot access {}'.format(args.destination))
        return False

    url = SCRAP_URL.format(args.jspeid)

    print('Requesting (may be long) ... ')

    r = requests.get(url)
    if r.status_code != 200:
        print('Connection status code is {} (try with a different JS_PEID?)'.format(r.status_code))
        return False

    print('... ok!')

    soup = BeautifulSoup(r.content, 'html.parser')
    script_parts = soup.find_all('script', {'language': 'JavaScript'})

    basis_sets = {}

    for script in script_parts:
        s = script.string
        if 'function basisSet(' in s:
            found_bs = s.find(DEFINITION_BS, 0)
            while found_bs != -1:
                found_end = s.find(');', found_bs)
                if found_end == -1:
                    raise Exception('found beginning but no end ?')
                found_lst = s.find('"[', found_bs)
                if found_lst == -1:
                    raise Exception('cannot find list of atom?')
                found_lst_end = s.find(']"', found_lst)
                if found_lst_end == -1:
                    raise Exception('cannot find end of list of atoms')

                definition = s[found_bs + len(DEFINITION_BS):found_end]
                x = definition[:found_lst_end-found_bs-len(DEFINITION_BS)].split('"')
                path, name, bs_type, atoms = x[1], x[3], x[5], x[7][1:]

                if bs_type == 'orbital':
                    basis_sets[name] = [path, atoms]

                found_bs = s.find(DEFINITION_BS, found_bs + 1)
            break

    if not basis_sets:
        raise Exception('failed to find basis sets in the ESML page (try with a different JS_PEID?)')

    try:
        with open(DESTINATION_FILE, 'w') as f:

            content_dict = ''

            for name, (path, atoms) in basis_sets.items():
                content_dict += \
                    '    \'{n}\': ESMLBasisSet(\n' \
                    '        \'{n}\',\n' \
                    '        \'{p}\',\n' \
                    '        {a}\n'.format(
                        n=name,
                        p=path,
                        a='[{}]),  # noqa'.format(', '.join('\'' + x.strip() + '\'' for x in atoms.split(','))))

            f.write(FILE_CONTENT.format(datetime.now().strftime('%B %d, %Y'), args.jspeid, content_dict))

            print('\nDone: {} orbital basis sets were retrieved (excluding ECP, polarization, diffuse ...)'.format(
                len(basis_sets)))
    except IOError as e:
        print(e)
        return False

if __name__ == '__main__':
    main()

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Numerical differentiation (qcip_tools.numerical_differentiation) &mdash; qcip_tools 0.6.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quantities (qcip_tools.quantities)" href="quantities.html" />
    <link rel="prev" title="Molecule (qcip_tools.molecule)" href="molecule.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> qcip_tools
          </a>
              <div class="version">
                0.6.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing qcip_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../code-documentation.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="atom.html">Atom (<code class="docutils literal notranslate"><span class="pre">qcip_tools.atom</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="basis_set.html">Basis set (<code class="docutils literal notranslate"><span class="pre">qcip_tools.basis_set</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="bounding.html">Bounding objects(<code class="docutils literal notranslate"><span class="pre">qcip_tools.bounding</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="chemistry_files.html">Chemistry files (<code class="docutils literal notranslate"><span class="pre">qcip_tools.chemistry_files</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives.html">Derivatives of the energy (<code class="docutils literal notranslate"><span class="pre">qcip_tools.derivatives</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives_e.html">Derivatives w.r.t. electric field (<code class="docutils literal notranslate"><span class="pre">qcip_tools.derivatives_e</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives_exci.html">Excitations (<code class="docutils literal notranslate"><span class="pre">qcip_tools.derivatives_exci</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives_g.html">Derivatives w.r.t. geometrical stuffs (<code class="docutils literal notranslate"><span class="pre">qcip_tools.derivatives_g</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html">Math helpers (<code class="docutils literal notranslate"><span class="pre">qcip_tools.math</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mixins.html">Mixins (<code class="docutils literal notranslate"><span class="pre">qcip_tools.mixins</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="molecule.html">Molecule (<code class="docutils literal notranslate"><span class="pre">qcip_tools.molecule</span></code>)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Numerical differentiation (<code class="docutils literal notranslate"><span class="pre">qcip_tools.numerical_differentiation</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mathematical-background">Mathematical background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#numerical-derivation">Numerical derivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#romberg-s-scheme-richardson-extrapolation">Romberg’s scheme (Richardson extrapolation)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sources">Sources</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-qcip_tools.numerical_differentiation">API documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quantities.html">Quantities (<code class="docutils literal notranslate"><span class="pre">qcip_tools.quantities</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetry.html">Symmetry (<code class="docutils literal notranslate"><span class="pre">qcip_tools.symmetry</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="transformations.html">Transformations (<code class="docutils literal notranslate"><span class="pre">qcip_tools.transformations</span></code>)</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">qcip_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../code-documentation.html">API documentation</a> &raquo;</li>
      <li>Numerical differentiation (<code class="docutils literal notranslate"><span class="pre">qcip_tools.numerical_differentiation</span></code>)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/code-documentation/numerical_differentiation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="numerical-differentiation-qcip-tools-numerical-differentiation">
<h1>Numerical differentiation (<code class="docutils literal notranslate"><span class="pre">qcip_tools.numerical_differentiation</span></code>)<a class="headerlink" href="#numerical-differentiation-qcip-tools-numerical-differentiation" title="Permalink to this headline"></a></h1>
<section id="mathematical-background">
<h2>Mathematical background<a class="headerlink" href="#mathematical-background" title="Permalink to this headline"></a></h2>
<section id="numerical-derivation">
<h3>Numerical derivation<a class="headerlink" href="#numerical-derivation" title="Permalink to this headline"></a></h3>
<section id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Permalink to this headline"></a></h4>
<p>This an application of the <a class="reference external" href="https://en.wikipedia.org/wiki/Neville%27s_algorithm">Neville’s algorithm</a>.</p>
<p>Let <span class="math notranslate nohighlight">\(M(x)\)</span> be a <a class="reference external" href="https://en.wikipedia.org/wiki/Taylor_series">Maclaurin series expansion</a> of a function <span class="math notranslate nohighlight">\(f(x)\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-expansion">
<span class="eqno">(1)<a class="headerlink" href="#equation-expansion" title="Permalink to this equation"></a></span>\[M(x) =  \sum_ {n=0}^{n_{max}} \frac{1}{n!}\frac{\partial^n f(0)}{\partial x^n} x^n = \sum_ {n=0}^{n_{max}} \frac{A_n}{n!} x^n,\]</div>
<p>where <span class="math notranslate nohighlight">\(A_n=f^{(n)}(0)\)</span>, the value of the <span class="math notranslate nohighlight">\(n\)</span>-order derivative of <span class="math notranslate nohighlight">\(f(x)\)</span> at <span class="math notranslate nohighlight">\(x=0\)</span>. If the expansion is not truncated, <span class="math notranslate nohighlight">\(n_{max}=\infty\)</span>.</p>
<p>Given a small value <span class="math notranslate nohighlight">\(h&gt;0\)</span> and <span class="math notranslate nohighlight">\(I_{a,q} \in \mathbb{R}\)</span>,</p>
<div class="math notranslate nohighlight">
\[M(h\,I_{a,q}) = \sum_{n=0}^{n_{max}} I_{a,q}^n\,\frac{A_n}{n!}\,h^n\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\forall q \in \mathbb{N}: I_{a,q} = \left\{\begin{matrix}-a^{|q|-1} &amp;\text{if }q&lt; 0,\\0 &amp;\text{if } q= 0, \\ a^{q-1} &amp; \text{if }q&gt; 0.\end{matrix}\right.\end{split}\]</div>
<p>Therefore, <span class="math notranslate nohighlight">\(\forall h \in \mathbb{R}^+:\forall k\in\mathbb{N}^0:h\,I_{a, k+1}=a^k\,h\)</span> defines a geometric progression where <span class="math notranslate nohighlight">\(h\)</span> is the smallest value and <span class="math notranslate nohighlight">\(a\)</span> is the common ratio (or scale factor).</p>
<p>An estimate of an <span class="math notranslate nohighlight">\(A_d\)</span> factor [value of <span class="math notranslate nohighlight">\(f^{(d)}(0)\)</span>] determined by using <span class="math notranslate nohighlight">\(h\)</span>, is given by</p>
<div class="math notranslate nohighlight">
\[A_d(h) = \frac{d!}{h^d}\,M^{(d)}(h) + \mathcal{O}(x^{d+1}),\]</div>
<p>where <span class="math notranslate nohighlight">\(M^{(d)}(h)\)</span> is the value at <span class="math notranslate nohighlight">\(h\)</span> of the <span class="math notranslate nohighlight">\(d\)</span>-order derivative of the Maclaurin series.</p>
<p>Let’s assume that one can determine <span class="math notranslate nohighlight">\(A_d(h)\)</span> with a given error <span class="math notranslate nohighlight">\(\mathcal{O}(h^{d+p}), p\in\mathbb{N}^+\)</span> by computing</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_d(h) &amp;= \frac{d!}{h^d}\,\sum_{q=q_{min}}^{q_{max}} C_q\,M(h\,I_{a,q})+  \mathcal{O}(h^{d+p}), \\
    &amp;= \frac{d!}{h^d}\,\sum_{q=q_{min}}^{q_{max}} C_q\, \sum_{n=0}^{n_{max}} I_{a,q}^n\,\frac{A_n}{n!}\,h^n+  \mathcal{O}(h^{d+p}), \\
    &amp;= \frac{d!}{h^d}\,\sum_{n=0}^{n_ {max}} \left[\sum_{q=q_{min}}^{q_{max}} I_{a,q}^n\,C_q\right]\,\frac{A_n}{n!}\,h^n +  \mathcal{O}(h^{d+p}).
\end{align}\end{split}\]</div>
<p>In order for the equality to be satisfied, it is necessary that:</p>
<div class="math notranslate nohighlight" id="equation-sys">
<span class="eqno">(2)<a class="headerlink" href="#equation-sys" title="Permalink to this equation"></a></span>\[\begin{split}\sum_{q=q_{min}}^{q_{max}} I_{a,q}^n\,C_q = \left\{
    \begin{array}{ll}
        1 &amp; \text{if }n=d,\\
        0 &amp; \text{otherwise.}
    \end{array}\right.\end{split}\]</div>
<p>This defines a set of <span class="math notranslate nohighlight">\(n_{max}\)</span> linear equations with <span class="math notranslate nohighlight">\(q_{max}-q_{min}+1\)</span> unknowns (<span class="math notranslate nohighlight">\(C_q\)</span>).
In order to get a unique solution, <span class="math notranslate nohighlight">\(q_{max}-q_{min}+1\geqslant d\)</span> and therefore, one can set <span class="math notranslate nohighlight">\(n_{max}=q_{max}-q_{min}+1= d+p\)</span>.
<span class="math notranslate nohighlight">\(q_{min}\)</span> and <span class="math notranslate nohighlight">\(q_{max}\)</span> take different values, depending of the approximation:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 43%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(i_{min}\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(i_{max}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Forward (<code class="docutils literal notranslate"><span class="pre">F</span></code>)</p></td>
<td><p>0</p></td>
<td><p><span class="math notranslate nohighlight">\(d+p-1\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Backward (<code class="docutils literal notranslate"><span class="pre">B</span></code>)</p></td>
<td><p><span class="math notranslate nohighlight">\(-d+p-1\)</span></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>Centered (<code class="docutils literal notranslate"><span class="pre">C</span></code>)</p></td>
<td><p><span class="math notranslate nohighlight">\(-\left\lfloor\frac{d+p-1}{2}\right\rfloor\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\left\lfloor\frac{d+p-1}{2}\right\rfloor\)</span></p></td>
</tr>
</tbody>
</table>
<p>Note that <span class="math notranslate nohighlight">\(p+d-1\)</span> should therefore always be even in the case of centered derivatives.</p>
<p>The system of linear equation given by Eq. <a class="reference internal" href="#equation-sys">(2)</a> is solved. Once the <span class="math notranslate nohighlight">\(C_q\)</span>’s are determined, <span class="math notranslate nohighlight">\(A_d(h)\)</span> is obtained with a precision <span class="math notranslate nohighlight">\(\mathcal{O}(h^{d+p})\)</span> by computing</p>
<div class="math notranslate nohighlight" id="equation-ad">
<span class="eqno">(3)<a class="headerlink" href="#equation-ad" title="Permalink to this equation"></a></span>\[A_d(h) = \frac{d!}{h^d}\,\sum_{q=q_{min}}^{q_{max}} C_q\,M(h\,I_{a,q}).\]</div>
<p>It can be simply showed that the coefficients for a multivariate function is a tensor product of the coefficients for the univariates approximations. In this case <span class="math notranslate nohighlight">\(A_d(\mathbf{h})\)</span> is a symmetric tensor, while <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> is a vector.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In pratice, it wouldn’t change anything if a Taylor series (not centered at <span class="math notranslate nohighlight">\(x=0\)</span>) is used instead. It also holds for power series if one discard the <span class="math notranslate nohighlight">\(d!\)</span> in <a class="reference internal" href="#equation-ad">(3)</a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If values of <span class="math notranslate nohighlight">\(M(h)\)</span> are known with a certain precision <span class="math notranslate nohighlight">\(\delta y\)</span>, the absolute error on <span class="math notranslate nohighlight">\(A_d(h)\)</span> cannot be lower than <span class="math notranslate nohighlight">\(\delta y \times h^{-d}\)</span>, no matter the order of magnitude of <span class="math notranslate nohighlight">\(A_d(h)\)</span>.
If there is no physical (or chemical) limitation to the precision, <span class="math notranslate nohighlight">\(\delta y\)</span> is then determined by the precision of the representation,
see the <a class="reference external" href="https://docs.python.org/3.6/tutorial/floatingpoint.html">python documentation on floating point arithmetic</a>.</p>
</div>
</section>
<section id="implementation">
<h4>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline"></a></h4>
<p>The <span class="math notranslate nohighlight">\(I_{a,q}\)</span> function is named <code class="docutils literal notranslate"><span class="pre">ak_shifted()</span></code> in the python code.</p>
<p>In the code, to works with the romberg triangles defined below, <span class="math notranslate nohighlight">\(h=a^{k}h_0\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the minimal amplitude, while <span class="math notranslate nohighlight">\(h_0\)</span> is the minimal value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Coefficients</span></code> class takes care of the computation of the different coefficients, storing them in <code class="docutils literal notranslate"><span class="pre">Coefficients.mat_coefs</span></code>.
The <span class="math notranslate nohighlight">\(\frac{d!}{h^d}\)</span> part can be computed via the <code class="docutils literal notranslate"><span class="pre">Coefficients.prefactor()</span></code> function.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">compute_derivative_of_function(c,</span> <span class="pre">scalar_function,</span> <span class="pre">k,</span> <span class="pre">h0,</span> <span class="pre">input_space_dimension,</span> <span class="pre">**kwargs)</span></code> function does the whole computation (for uni and multivariate functions) and gives <span class="math notranslate nohighlight">\(A_d(h)\)</span> (which is the component of a tensor in the case of multivariate functions).
A <code class="docutils literal notranslate"><span class="pre">scalar_function(fields,</span> <span class="pre">h_0,</span> <span class="pre">**kwargs)</span></code> function must be defined, which must return the value of the Maclaurin expansion <span class="math notranslate nohighlight">\(\mathbf{M}_i(\mathbf{x})\)</span>,  with <span class="math notranslate nohighlight">\(\mathbf{M}:\mathbb{R}^n\rightarrow\mathbb{R}^m\)</span> (where <cite>n</cite> is the input space dimension), given <span class="math notranslate nohighlight">\(n\)</span> <code class="docutils literal notranslate"><span class="pre">fields</span></code> (the <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> vector), corresponding to the different <span class="math notranslate nohighlight">\(q\)</span>.
Since the function expects real values, <span class="math notranslate nohighlight">\(i\)</span> (the <span class="math notranslate nohighlight">\(i^\text{th}\)</span> coordinate of <span class="math notranslate nohighlight">\(\mathbf{M}(\mathbf{x})\in\mathbb{R}^m\)</span>) must be passed thought <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> if any.
<code class="docutils literal notranslate"><span class="pre">c</span></code> is a list of tuple <code class="docutils literal notranslate"><span class="pre">(Coefficient,</span> <span class="pre">int)</span></code>, which define the derivatives to compute and with respect to which coordinates (starting by 0) the differentiation must be performed.</p>
<p>For example, given <span class="math notranslate nohighlight">\(E:\mathbb{R}^3\rightarrow\mathbb{R}\)</span>, computation of <span class="math notranslate nohighlight">\(\frac{\partial^3E(\mathbf{x})}{\partial \mathbf{x}_0\partial\mathbf{x}_1^2}\)</span> is requested via</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">first_order</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">second_order</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

<span class="n">derivative_values</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># compute d^3 E(x) / dx0 dx1^2</span>
<span class="n">derivative_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">compute_derivative_of_function</span><span class="p">(</span>
    <span class="p">[(</span><span class="n">first_order</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">second_order</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
    <span class="n">E</span><span class="p">,</span>  <span class="c1"># assume defined</span>
    <span class="mi">0</span><span class="p">,</span>  <span class="c1"># k = 0</span>
    <span class="mf">0.001</span><span class="p">,</span>  <span class="c1"># h0</span>
    <span class="mi">3</span>  <span class="c1"># input space is R³.</span>
<span class="p">))</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the code, <span class="math notranslate nohighlight">\(k\)</span> is added (or substracted) to <span class="math notranslate nohighlight">\(q\)</span> so that <code class="docutils literal notranslate"><span class="pre">scalar_function()</span></code> receives the <span class="math notranslate nohighlight">\(q\)</span> values with respect to <span class="math notranslate nohighlight">\(h_0\)</span> and is expected to returns the value of <span class="math notranslate nohighlight">\(M(I_{a,q}h_0)\)</span>.</p>
</div>
</section>
</section>
<section id="romberg-s-scheme-richardson-extrapolation">
<h3>Romberg’s scheme (Richardson extrapolation)<a class="headerlink" href="#romberg-s-scheme-richardson-extrapolation" title="Permalink to this headline"></a></h3>
<section id="id1">
<h4>Theory<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h4>
<p>In quantum chemistry, the <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson_extrapolation">Richardson extrapolation</a> is also known as the Romberg differentiation scheme.
Like its integration counterpart, it allows to refine the value of a numerical derivatives by computing multiple estimate of the derivates.</p>
<p>Given Eq. <a class="reference internal" href="#equation-expansion">(1)</a> and a small <span class="math notranslate nohighlight">\(h \in \mathbb{R}^+\)</span>, <span class="math notranslate nohighlight">\(r, m \in \mathbb{N}^+\)</span>, <span class="math notranslate nohighlight">\(k \in \mathbb{N}^0\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    a^{rm}\,M(a^k h) - M(a^{k+1} h) &amp;= a^{rm}\,\sum_ {n=0}^{n_{max}} a^{nk}\,\frac{A_n}{n!} h^n - \sum_ {n=0}^{n_{max}} a^{nk+n}\,\frac{A_n}{n!} h^n \\
        &amp;= \sum_ {n=0}^{n_{max}} [a^{nk+rm}-a^{nk+n}]\frac{A_n}{n!} h^n.
\end{align}\end{split}\]</div>
<p>It is therefore possible to remove the <span class="math notranslate nohighlight">\(s\)</span>-power term from the expansion by choosing <span class="math notranslate nohighlight">\(s=rm\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(H_{k,0}\equiv A_d(h=a^k h_0)\)</span> with <span class="math notranslate nohighlight">\(h_0\)</span> the minimal value, the following recurrence relation can be defined:</p>
<div class="math notranslate nohighlight" id="equation-romberg">
<span class="eqno">(4)<a class="headerlink" href="#equation-romberg" title="Permalink to this equation"></a></span>\[H_{k,m} = \frac{a^{rm}\,H_{k,m-1}-H_{k+1,m-1}}{a^{rm}-1} + \mathcal{O}(h^{r(m+1)}),\]</div>
<p>where <span class="math notranslate nohighlight">\(m\)</span> is the number of <em>refinement</em> steps or iterations. To achieve such a <span class="math notranslate nohighlight">\(\mathcal{O}(h^{rm})\)</span> precision, it is required to know <span class="math notranslate nohighlight">\(m+1\)</span> values of <span class="math notranslate nohighlight">\(H_{k,0}\)</span> with <span class="math notranslate nohighlight">\(k\in [0;m+1]\)</span>.
In general, <span class="math notranslate nohighlight">\(r\)</span> should be equal to 1 to remove the <span class="math notranslate nohighlight">\(m\)</span>-power contamination at iteration <span class="math notranslate nohighlight">\(m\)</span>, but in the case of centered derivatives, every odd-power term vanishes, so one can use <span class="math notranslate nohighlight">\(r=2\)</span> to achieve a faster convergence by removing the <span class="math notranslate nohighlight">\(2m\)</span>-power contamination at iteration <span class="math notranslate nohighlight">\(m\)</span>.</p>
<p>A romberg triangle is obtained, with the following shape:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>k=  | h=    |  m=0     m=1     m=2    ...
----+-------+-----------------------------
0   | a⁰*h0 |  val01   val11   val20  ...
1   | a¹*h0 |  val02   val12   ...
2   | a²*h0 |  val03   ...
... | ...   |  ...
</pre></div>
</div>
<p>If the minimal value <span class="math notranslate nohighlight">\(h_0\)</span> is chosen well, the value of the derivative should be the rightmost value. In practice, there is a value window with lower bound (for which there are too large round-off errors) and larger bound (when higher order terms makes the number of <span class="math notranslate nohighlight">\(a^kh_0\)</span> required large, along with quantum chemistry related reasons which lower that value).
Without knowledge of this ideal <span class="math notranslate nohighlight">\(h_0\)</span> window, it is necessary to carry out an analysis of the triangle to select the “best” value. Two quantities are usefull:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    &amp;\varepsilon_k(m) = H_{k+1,m} - H_{k,m}, \\
    &amp;\varepsilon_{m}(k) = H_{k,m+1} - H_{k,m},
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\varepsilon_k(m)\)</span> is the amplitude error at a given iteration <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(\varepsilon_m(k)\)</span> is the iteration error for a given amplitude <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>This “best” value is chosen according to the following flowchart:</p>
<figure class="align-center" id="id3">
<img alt="../_images/flowchart_romberg_selection.png" src="../_images/flowchart_romberg_selection.png" />
<figcaption>
<p><span class="caption-text">Flowchart to select the “best” value in a Romberg triangle, adapted from the text in M. de Wergifosse <em>et al</em>. <em>Int. J. Quant. Chem.</em> <strong>114</strong>, 900 (2014).</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Note that the original paper does not give advices on what the threshold value should be, but it clearly depends on the order of magnitude of <span class="math notranslate nohighlight">\(A_d(h)\)</span> and the available (and/or required) precision.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case where <span class="math notranslate nohighlight">\(A_d(\mathbf{h}=a^k\mathbf{h}_0)\)</span> is a tensor (because the corresponding function is multivariate), a Romberg triangle must be carried out for each component of this tensor.
But since the vector is symmetric, it can reduce the number of components to carry out.</p>
</div>
</section>
<section id="id2">
<h4>Implementation<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">RombergTriangle</span></code> class implement the Romberg’s triangle algorithm. The constructors expect the value corresponding to increasing <code class="docutils literal notranslate"><span class="pre">k</span></code> values to be passed as argument.</p>
<p>The <span class="math notranslate nohighlight">\(H_{k,m}\)</span> are available as <code class="docutils literal notranslate"><span class="pre">RombergTriangle.romberg_triangle[k,</span> <span class="pre">m]</span></code>. Note that the values for which <span class="math notranslate nohighlight">\(k \geqslant k_{max} - m\)</span> are set to zero.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">find_best_value()</span></code> implement the flowchart showed above. To help the (eventual) debugging and understanding, a <code class="docutils literal notranslate"><span class="pre">verbose</span></code> option is available.</p>
<p>For example, for an univariate function <span class="math notranslate nohighlight">\(F(x)\)</span>, compute <span class="math notranslate nohighlight">\(\frac{dF(x)}{dx}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="c1"># Forward first order derivative:</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="n">derivative_values</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># compute dF(x) / dx</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">derivative_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">compute_derivative_of_function</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>  <span class="c1"># derivative with respect to the first (and only) variable</span>
        <span class="n">univariate_function</span><span class="p">,</span>  <span class="c1"># assume defined</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="mf">0.001</span><span class="p">,</span>  <span class="c1"># f0</span>
        <span class="mi">1</span>  <span class="c1"># R → R</span>
    <span class="p">))</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">RombergTriangle</span><span class="p">(</span><span class="n">derivative_values</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="n">position</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">iteration_error</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">find_best_value</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For a bivariate function <span class="math notranslate nohighlight">\(F(x, y)\)</span>, compute <span class="math notranslate nohighlight">\(\frac{\partial^3 F(x, y)}{\partial x \partial y^2}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="c1"># centered first and second order derivative:</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">derivative_values</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># compute d³F(x,y) / dxdy²</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">derivative_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">compute_derivative_of_function</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>  <span class="c1"># first and second order derivative with respect to the first and second variable</span>
        <span class="n">bivariate_function</span><span class="p">,</span>  <span class="c1"># assume defined</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="mf">0.001</span><span class="p">,</span>  <span class="c1"># f0</span>
        <span class="mi">2</span>  <span class="c1"># R² → R</span>
    <span class="p">))</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">RombergTriangle</span><span class="p">(</span><span class="n">derivative_values</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># r=2 because centered</span>
<span class="n">position</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">iteration_error</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">find_best_value</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="sources">
<h2>Sources<a class="headerlink" href="#sources" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>D. Eberly, « Derivative Approximation by Finite Difference ». From the <a class="reference external" href="https://www.geometrictools.com/Documentation/Documentation.html">Geometric Tools documentation</a> (last consultation: March 4, 2017).</p></li>
<li><p>J.N. Lyness <em>et al</em>. <em>Numer. Math.</em> <strong>8</strong>, 458 (1966).</p></li>
<li><p>L.F. Richardson <em>et al</em>. <em>Philosophical Transactions of the Royal Society of London. Series A, Containing Papers of a Mathematical or Physical Character</em> <strong>226</strong>, 299 (1927).</p></li>
<li><p>M. de Wergifosse <em>et al</em>. <em>Int. J. Quant. Chem.</em> <strong>114</strong>, 900 (2014).</p></li>
<li><p>A.A.K. Mohammed <em>et al</em>. <em>J. Comp. Chem.</em> <strong>34</strong>, 1497 (2013).</p></li>
</ul>
</section>
<section id="module-qcip_tools.numerical_differentiation">
<span id="api-documentation"></span><h2>API documentation<a class="headerlink" href="#module-qcip_tools.numerical_differentiation" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.Coefficients">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qcip_tools.numerical_differentiation.</span></span><span class="sig-name descname"><span class="pre">Coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.Coefficients" title="Permalink to this definition"></a></dt>
<dd><p>Class to store the coefficients for the derivative calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – derivation order</p></li>
<li><p><strong>p</strong> (<em>int</em>) – order of error</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – ratio (a)</p></li>
<li><p><strong>method</strong> (<em>str</em>) – derivation method, either forward (F), backward (B) or centered (C)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.Coefficients.choose_p_for_centered">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">choose_p_for_centered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.Coefficients.choose_p_for_centered" title="Permalink to this definition"></a></dt>
<dd><p>Choose the precision so that <span class="math notranslate nohighlight">\(d+p-1\)</span> is even (for centered derivatives)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – order of the derivative</p></li>
<li><p><strong>shift</strong> (<em>int</em>) – increase the precision</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.Coefficients.prefactor">
<span class="sig-name descname"><span class="pre">prefactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.Coefficients.prefactor" title="Permalink to this definition"></a></dt>
<dd><p>return the <span class="math notranslate nohighlight">\(\frac{d!}{h^d}\)</span> prefactor, with <span class="math notranslate nohighlight">\(h=a^kh_0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h0</strong> (<em>float</em>) – minimal value</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Minimal amplitude</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>prefactor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.RombergTriangle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qcip_tools.numerical_differentiation.</span></span><span class="sig-name descname"><span class="pre">RombergTriangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.RombergTriangle" title="Permalink to this definition"></a></dt>
<dd><p>Do a Romberg triangle to lower (remove) the influence of higher-order derivatives.</p>
<p>Note: Romberg triangle indices are n, then k (but printing require n to be column, so invert them !)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vals</strong> (<em>list</em>) – list of derivatives, the first one calculated with the lowest k, the last one the larger</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – ratio (a)</p></li>
<li><p><strong>r</strong> (<em>int</em>) – derivatives to remove. r=1 for backward and forward approximation and 2 for centered approximation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.RombergTriangle.amplitude_error">
<span class="sig-name descname"><span class="pre">amplitude_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.RombergTriangle.amplitude_error" title="Permalink to this definition"></a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\varepsilon_k(m) = H_{k+1,m} - H_{k,m}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em>) – amplitude</p></li>
<li><p><strong>m</strong> (<em>int</em>) – iteration</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.RombergTriangle.find_best_value">
<span class="sig-name descname"><span class="pre">find_best_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold=1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.RombergTriangle.find_best_value" title="Permalink to this definition"></a></dt>
<dd><p>Find the “best value” in the Romberg triangle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em>) – threshold for maximum iteration error</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – get an insight of how the value was chosen</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of 3 information: position (tuple), value (float), iteration error (float)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.RombergTriangle.iteration_error">
<span class="sig-name descname"><span class="pre">iteration_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.RombergTriangle.iteration_error" title="Permalink to this definition"></a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\varepsilon_m(k) = H_{k,m+1} - H_{k,m}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em>) – amplitude</p></li>
<li><p><strong>m</strong> (<em>int</em>) – iteration</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.RombergTriangle.romberg_triangle_repr">
<span class="sig-name descname"><span class="pre">romberg_triangle_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_decoration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.RombergTriangle.romberg_triangle_repr" title="Permalink to this definition"></a></dt>
<dd><p>Print the Romberg triangle …</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.ak_shifted">
<span class="sig-prename descclassname"><span class="pre">qcip_tools.numerical_differentiation.</span></span><span class="sig-name descname"><span class="pre">ak_shifted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.ak_shifted" title="Permalink to this definition"></a></dt>
<dd><p>Match the <span class="math notranslate nohighlight">\(k\)</span> and the real <span class="math notranslate nohighlight">\(a^k\)</span> value.</p>
<p>For a given <span class="math notranslate nohighlight">\(q\)</span>, returns</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{
    \begin{array}{ll}
        -a^{|q|-1} &amp; \text{if }q&lt;0\\
        0 &amp; \text{if }k=0\\
        a^{q-1}&amp;\text{if }q&gt;0
    \end{array}\right.\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>int</em>) – q</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – ratio (a)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.compute_derivative_of_function">
<span class="sig-prename descclassname"><span class="pre">qcip_tools.numerical_differentiation.</span></span><span class="sig-name descname"><span class="pre">compute_derivative_of_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_space_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.compute_derivative_of_function" title="Permalink to this definition"></a></dt>
<dd><p>Compute the numerical derivative of a scalar, calling the appropriate results through <code class="docutils literal notranslate"><span class="pre">scalar_function</span></code>,
to which the <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> parameter is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>list</em>) – list of tuple to describe the numerical derivative (Coefficient, coordinate)</p></li>
<li><p><strong>scalar_function</strong> (<em>callback</em>) – a callback function to access the different quantities</p></li>
<li><p><strong>k</strong> (<em>int</em>) – minimal amplitude</p></li>
<li><p><strong>h0</strong> (<em>float</em>) – minimal value</p></li>
<li><p><strong>input_space_dimension</strong> (<em>int</em>) – dimension of the input vector space</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – other arguments, transfered to <code class="docutils literal notranslate"><span class="pre">scalar_function()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value of the derivative (as a scalar)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qcip_tools.numerical_differentiation.real_fields">
<span class="sig-prename descclassname"><span class="pre">qcip_tools.numerical_differentiation.</span></span><span class="sig-name descname"><span class="pre">real_fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fields</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qcip_tools.numerical_differentiation.real_fields" title="Permalink to this definition"></a></dt>
<dd><p>Return the “real value” of the field applied</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fields</strong> (<em>list</em>) – input field (in term of ak)</p></li>
<li><p><strong>min_field</strong> (<em>float</em>) – minimal field</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – ratio</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="molecule.html" class="btn btn-neutral float-left" title="Molecule (qcip_tools.molecule)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quantities.html" class="btn btn-neutral float-right" title="Quantities (qcip_tools.quantities)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Pierre Beaujean (University of Namur).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>